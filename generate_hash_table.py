#!/usr/bin/env python3
import sys
import argparse
from typing import List, Dict, Set

# -----------------------------------------------------------------------------
# 1. REPLICATION OF THE C LOGIC (from your components.py)
# This section ensures the hashing algorithm is identical to your C code.
# -----------------------------------------------------------------------------

def crc32(data: List[int]) -> int:
    """
    Calculates a 32-bit CRC hash on a list of 32-bit integers (codepoints).
    This is a direct Python port of the bitwise CRC32 implementation
    from the provided C code.
    """
    crc = 0xFFFFFFFF
    poly = 0x04C11DB7

    if not data:
        return 0

    for item in data:
        for j in range(32):
            bit = (item >> (31 - j)) & 1
            if ((crc >> 31) & 1) != bit:
                crc = ((crc << 1) ^ poly)
            else:
                crc = (crc << 1)
            crc &= 0xFFFFFFFF
            
    return crc

def is_base_emoji(cp: int) -> bool:
    """
    Checks if a codepoint is a base emoji character, mirroring the C helper.
    Returns False for modifiers like skin tones, ZWJ, and gender signs.
    """
    if 0x1F3FB <= cp <= 0x1F3FF:  # Skin Tones
        return False
    # ZWJ, Variation Selectors, and Gender signs are not base emojis
    if cp in [0x200D, 0xFE0F, 0x2640, 0x2642]:
        return False
    return True

def parse_emoji_string(emoji_str: str) -> Dict:
    """
    Parses a UTF-8 emoji string into its components, just like the C code,
    to identify the primary codepoint and the component list for hashing.
    """
    components = {
        'primary_cp': 0,
        'component_list': [],
        'hash': 0
    }
    
    codepoints = [ord(c) for c in emoji_str]

    for cp in codepoints:
        # We only care about base emojis for the primary and component list
        if is_base_emoji(cp):
            if components['primary_cp'] == 0:
                components['primary_cp'] = cp
            else:
                components['component_list'].append(cp)

    if components['component_list']:
        components['hash'] = crc32(components['component_list'])
        
    return components

# -----------------------------------------------------------------------------
# 2. FILE PROCESSING AND C CODE GENERATION
# -----------------------------------------------------------------------------

def process_unicode_file(file_path: str, hash_map: Dict[int, List[int]], seen_emojis: Set[str]):
    """
    Reads a Unicode data file, parses ZWJ sequences, and populates the hash_map.
    """
    sys.stderr.write(f"Processing file: {file_path}...\n")
    
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            # Skip comments and empty lines
            if line.startswith('#') or not line.strip():
                continue
            
            # We are only interested in ZWJ sequences for the component hash table
            if 'ZWJ' not in line:
                continue

            # Extract the emoji character sequence from the line
            try:
                # Format is typically `... ; status # EMOJI ...`
                emoji_char = line.split('#')[1].strip().split(' ')[0]
            except IndexError:
                continue # Line doesn't contain a parsable emoji character

            # Skip duplicates to avoid redundant processing
            if emoji_char in seen_emojis:
                continue
            seen_emojis.add(emoji_char)

            # Parse the string to find components and generate a hash
            parsed = parse_emoji_string(emoji_char)
            
            # We only add entries that have components (and thus a hash)
            if parsed['hash'] != 0 and parsed['component_list']:
                # Store the component list, keyed by its hash.
                # This automatically handles duplicates from different files.
                hash_map[parsed['hash']] = parsed['component_list']

def generate_c_code(hash_map: Dict[int, List[int]]):
    """
    Generates the C header file content from the final hash map.
    """
    print("/*")
    print(" * Generated by generate_hash_table.py. DO NOT EDIT MANUALLY.")
    print(f" * Total Unique ZWJ Component Hashes: {len(hash_map)}")
    print(" */\n")
    print("static const EmojiHashEntry emoji_hash_table[] = {")

    # Sort by hash for a consistent, deterministic output
    sorted_hashes = sorted(hash_map.keys())
    
    for hash_val in sorted_hashes:
        components = hash_map[hash_val]
        count = len(components)
        
        # Format components as a C array initializer list (e.g., { 0x2194 })
        components_c_array = ", ".join([f"0x{cp:X}" for cp in components])
        
        # Format the final line for the C struct
        print(f"    {{ 0x{hash_val:08X}, {count}, {{ {components_c_array} }} }},")
        
    print("};")
    print("\nconst size_t num_hash_entries = sizeof(emoji_hash_table) / sizeof(emoji_hash_table[0]);")


def main():
    """
    Main function to parse arguments and drive the generation process.
    """
    parser = argparse.ArgumentParser(
        description="Generate a C hash table from Unicode emoji data files."
    )
    parser.add_argument(
        "files",
        nargs='+',
        help="Paths to emoji-test.txt, emoji-sequences.txt, etc."
    )
    args = parser.parse_args()

    # Master map to store final {hash: [component_list]} pairs
    master_hash_map = {}
    # Set to track processed emoji strings to avoid duplicates
    seen_emojis = set()

    for file_path in args.files:
        try:
            process_unicode_file(file_path, master_hash_map, seen_emojis)
        except FileNotFoundError:
            sys.stderr.write(f"Error: File not found at '{file_path}'\n")
            sys.exit(1)
            
    sys.stderr.write("\nGeneration complete.\n")
    generate_c_code(master_hash_map)


if __name__ == "__main__":
    main()
